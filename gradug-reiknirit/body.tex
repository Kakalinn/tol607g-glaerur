\title{Gráðug reiknirit}
\author{Bergur Snorrason}
\date{\today}

\begin{document}

\frame{\titlepage}

\env{frame}
{
	\frametitle{Gráðug reiknirit}
	\env{itemize}
	{
		\item<1-> Reiknirit sem tekur í hverju skrefi ákvörðun byggða á því hvað lítur best út á þeim tímapunkti kallast \emph{gráðugt}.
		\item<2-> Höfum í huga að það er alls ekki sjálfsagt að gráðugt reiknirit skili réttri lausn.
		\item<3-> Tökum dæmi.
	}
}

\env{frame}
{
	\frametitle{Dæmi}
	\env{itemize}
	{
		\item<1-> 
			Þú vinnur í sjoppu of þarft að gefa $n$ krónur í afgang. 
			Í boði er ótakmarkað magn af $1$ krónum, $5$ krónum og $10$ krónum.
			Hver er minnsti fjöldi af klinki sem þú getur gefið?
		\item<2-> Dæmi um lausn er:
		\item<3-> Látum $k$ tákna dýrasta klinkið sem er ekki dýrara en $n$. Gefum til baka $k$ og endurtökum fyrir $n - k$ þangað til $n$ er $0$.
		\item<4-> Tökum til dæmis $n = 24$. Þá myndum við gefa $10, 10, 1, 1, 1, 1$ til baka.
		\item<5-> Það vill svo skemmtilega til að þessi gráðuga lausn virkar fyrir öll $n$.
		\item<6-> En hvað ef við breytum aðeins dæminu?
	}
}

\env{frame}
{
	\frametitle{Dæmi}
	\env{itemize}
	{
		\item<1-> 
			Þú vinnur í sjoppu of þarft að gefa $n$ krónur í afgang. 
			Í boði er ótakmarkað magn af $1$ krónum, $8$ krónum og $20$ krónum.
			Hver er minnsti fjöldi af klinki sem þú getur gefið?
		\item<2-> Tökum til dæmis $n = 24$. Þá myndum aðferðin í glærunni á undan gefa $20, 1, 1, 1, 1$ til baka.
		\item<3-> En þetta er ekki besta leiðin. Betra væri að gefa $8, 8, 8$.
		\item<4-> Svo gráðuga aðferðin virkar bara stundum.
		\item<5-> Þetta dæmi er þekkt sem Skiptimyntadæmið (e. \emph{The Coin Change Problem}) og það er ekki augljóst hvenær gráðuga lausnin virkar.
	}
}

\env{frame}
{
	\frametitle{Dæmi}
	\env{itemize}
	{
		\item<1-> 
			Þú ert yfirmaður hjá leigubíla fyrirtæki.
			Í dag mættu $n$ bílstjórar í vinnuna og það eru $m$ leigubílar til að skipa bílstjóra á.
			Ekki eru þó allir bílstjórar og leigubílar skapaðir jafnir.
			Bíll $i$ er $h_i$ hestöfl og bílstjóri $j$ getur keyrt bíla sem eru $g_j$ hestöfl eða minna.
			Hver er mesti fjöldi bíla sem þú getur skipað á bílstjóra
				þannig að hver bílstjóri fær mest einn bíl,
				hver bíll er með mest einn bílstjóra og
				enginn bílstjóri fær bíl sem hann ræður ekki við.
			Gerum ráð fyrir að bílarnir og bílstjórarnir séu gefnir í vaxandi röð.
		\item<2-> Tökum eftir að við viljum að bíll sé keyrður af þeim bílstjóra sem er óreyndastur (en þó nógu hæfur til að keyra hann).
		\item<3-> Við getum því í línulegum tíma fundið þann bílstjóra sem getur keyrt fyrsta bíl.
		\item<4-> Til að finna bílstjóra fyrir næstu bíla leitum við aftur línulega, en höldum áfram þaðan sem við hættum áðan.
	}
}

\env{frame}
{
	Að neðan er útfærsla á lausninni á glærunum hér á undan. Fyrstu tvær tölurnar á inntakinu eru $n$ og $m$. 
		Næstu $n$ tölur lýsa getu bílstjóranna.
		Síðustu $m$ tölurnar eru hestöfl bílanna.
		\code{code/loowater.cpp}
}

\env{frame}
{
	\frametitle{Lausn}
	\env{itemize}
	{
		\item<1-> Þessi lausn er $\mathcal{O}($\onslide<2->{$n + m$}$)$.
	}
}

\env{frame}
{
	\env{itemize}
	{
		\item<1-> Það fyrsta sem manni dettur í hug þegar maður les dæmi er oft gráðug lausn.
		\item<2-> Það getur samt verið erfitt að sanna að gráðug lausn sé rétt.
		\item<3-> Það dugar þó að sannfæra sjálfan sig (og liðsfélag í liðakeppnum).
		\item<4-> Ef maður útfærir og sendir inn gráðuga lausn og fær \texttt{WA}
					getur verið erfitt að átta sig á því hvort maður hafi gert villu eða hvort gráðuga lausnin sé röng.
	}
}

\env{frame}
{
	\env{itemize}
	{
		\item<1-> Áðan röðuðum við tölum með tæmandi leit.
		\item<2-> Endurtökum nú leikinn með gráðugri nálgun.
		\item<3-> Ef við ætlum að raða í vaxandi röð þá vitum við að minnsta talan fer fremst.
		\item<4-> Við getum því raðað listanum gráðugt með því að setja ítrekað minnstu töluna sem er eftir fremst.
	}
}

\env{frame}
{
	\selectcode{code/slow-sort.cpp}{4}{13}
}

\env{frame}
{
	\env{itemize}
	{
		\item<1-> Tímaflækjan á þessu röðunar reikniriti er $\mathcal{O}($\onslide<2->{$n^2$}$)$.
		\item<3-> Við getum þó bætt tímaflækjun þegar við leitum að minnsta stakinu.
		\item<4-> Það eru ýmsar gagnagrindir sem geta gert þetta fyrir okkur.
		\item<5-> Af sögulegum ástæðum notum við forgangsbiðröð, en það mætti, til dæmis, líka nota ýmis röðunartré.
	}
}

\env{frame}
{
	\selectcode{code/sort.cpp}{4}{10}
}

\env{frame}
{
	\env{itemize}
	{
		\item<1-> Núna finnum við minnsta stakið í $\mathcal{O}($\onslide<2->{$\log n$}$)$.
		\item<3-> Svo tímaflækjan á fallinu er $\mathcal{O}($\onslide<4->{$n \log n$}$)$.
		\item<5-> Við getum í rauninni ekki raðað með betri tímaflækju.
		\item<6-> Þessi röðun kallast \emph{hrúguröðun} (e. \emph{heap sort}), þekkt röðunar reiknirit sem er oft kennt í inngangsnámskeiðum.
	}
}

\env{frame}
{
	\frametitle{Samantekt}
	\env{itemize}
	{
		\item<1-> Tæmandi leit er oft auðvelta að bera kennsl á, en á það til að vera of hæg. 
		\item<2-> Hér má búast við TLE, en eitthvað furðulegt hefur gerst ef maður fær WA.
		\item<3-> Það er oft létt að semja gráðug reiknirit, en það getur verið mikil vinna að sanna að lausnin sem maður fær sé alltaf rétt.
		\item<4-> Gráðug reiknirit eiga ekki að fá TLE, en algengt er að þau fái WA.
	}
}

\env{frame}
{
}

\end{document}
